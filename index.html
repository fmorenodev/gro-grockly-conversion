<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- Autores: Aitor Moya Lopez (Grockly) and Fernando Moreno Bendala (Traductor Gro a Grockly) -->
    <title>Grockly Web Simulator</title>

    <!-- Librerias de blockly-->
    <script src="blockly_compressed.js"></script>
    <script src="blocks_compressed.js"></script>
    <script src="msg/js/en.js"></script>
    <script src="javascript_compressed.js"></script>
    <script src="js/jquery-3.2.1.js"></script>
    <script src="js/FileSaver.js"></script>
    <!--Bloques Geneticos-->
    <script src="blocks/Genetics.js"></script>
    <!--Bloques de Acciones-->
    <script src="blocks/Nutrients.js"></script>
    <script src="blocks/Action.js"></script>
    <script src="blocks/Signals.js"></script>


</head>
<body>
<script>
    let screenSize = screen.height - 100;
</script>
<!--Entorno de Bloques-->
<div id="blocklyDiv"
     style="position:  relative; width: 100%; top: 0; left: 0; background:  #ccc; float: left;  height: 90vh;"></div>
<!--Entorno de Salida de codigo-->
<!--<div id="groDiv"
     style="position:  relative; width: 40%; top: 0; right: 0; background: #ddf; float: right; height: 650px; overflow:scroll;"></div>-->
<!--Menu de Bloques-->
<xml id="toolbox" style="display: none">
    <!--Tabla de Bloques-->
    <category name="Experiment">
        <block type="Experiment"></block>
    </category>

    <category name="Ecoli">
        <block type="Ecoli"></block>
    </category>

    <category name="Plasmid">
        <block type="Plasmid"></block>
    </category>

    <category name="Operon">
        <block type="Operon"></block>
    </category>

    <category name="Promoter">
        <block type="Promoter"></block>
    </category>

    <category name="Protein">
        <block type="Protein"></block>
        <block type="ProteinL"></block>
    </category>
    <category name="Actions">

        <block type="Action"></block>
        <block type="Paint"></block>
        <block type="Paint2"></block>
        <block type="Conjugate"></block>
        <block type="ActionR1"></block>
        <block type="ActionR2"></block>
        <block type="ActionR3"></block>
        <block type="DumpSingle"></block>
    </category>
    <category name="Components">
        <category name="Nutrients">
            <block type="Nutrients"></block>
        </category>
        <category name="Signals">
            <block type="Signal_Settings"></block>
            <block type="Signal"></block>
        </category>
    </category>


</xml>
<!--Conjunto de bloques iniciales -->
<xml id="startBlocks" style="display: none">
    <block type="Experiment" inline="false" x='0' y='0'>
    </block>

</xml>

<script>
    var workspace = Blockly.inject('blocklyDiv',
        {
            media: '/media/',
            toolbox: document.getElementById('toolbox'),
            zoom: {controls: true, wheel: true, startScale: 1.0, maxScale: 3, minScale: 0.3, scaleSpeed: 1.2},
            Âºtrashcan: true
        });
    Blockly.Xml.domToWorkspace(document.getElementById('startBlocks'),
        workspace);
</script>
<script>
    /**---------------------------------------------------------------------------------------------
     ESTRUCTURA DE ALMACENAMIENTO DE DATOS
     -----------------------------------------------------------------------------------------------**/

    var groCode = ' include gro ' + "<p/>";
    var promArray = [];
    var protArray = [];
    var operArray = [];
    var plasArray = [];
    var expArray = [];
    var cellArray = [];
    var transFactors = [];
    var actionCode;
    var signalCode;
    var programCode;


    /**---------------------------------------------------------------------------------------------
     FUNCIONES ENCARGADAS DE LA ESCRITURA DE LOS BLOQUES GENETICOS
     -----------------------------------------------------------------------------------------------**/
    /**Cada metodo implementado abajo, genera el codigo .GRO relativo a la estructura representada
     * con bloques previamente
     * El conjunto de arrays  se utilizan como soporte para mantener la informacion recogida en
     * los bloques previamente colocados.
     * Cada metodo codifica una parte del codigo que se van ensablando de forma recursiva
     * en algunos casos.
     * El metodo WriteMain() ensambla todas las partes y genera el archivo .GRO
     *
     **/


    function writeExperiment() {
        return xx = groCode + '\n' + 'set("dt",' + expArray[0][0] + ');\nset("population_max",' + expArray[0][1] + ');\n';
    }

    /**---------------------------------------------------------------------------------------------
     FUNCION CODIFICADORA DE LA INFORMACION RELATIVA AL PROMOTOR
     -----------------------------------------------------------------------------------------------**/
    function writePromoter(operonName) {
        var xx = buscaNombre(operonName, promArray);
        var groCode = 'promoter:=[function:="' + xx[0][1] + '",transcription_factors:={';
        for (var h = 2; h < xx[0].length; h++) {
            if (h == 2) {
                groCode = groCode + '"' + xx[0][h] + '"';
            }
            else {
                groCode = groCode + ',"' + xx[0][h] + '"'
            }
        }
        groCode = groCode + "}";
        return groCode;
    }

    /**---------------------------------------------------------------------------------------------
     FUNCION CODIFICADORA DE LA INFORMACION RELATIVA AL OPERON
     -----------------------------------------------------------------------------------------------**/
    function writeGenes() {
        var groCode2;
        var noise;
        for (var t = 0; t < operArray.length; t++) {
            if (t == 0) {
                noise = "noise:=[toOff:=" + operArray[t][1] + ",toOn:=" + operArray[t][2] + ",noise_time:=" + operArray[t][3] + "]]";
                groCode2 = 'genes([name:="' + operArray[t][0] + '",' + writeProtein(operArray[t][0], noise);
            }
            else {
                noise = "noise:=[toOff:=" + operArray[t][1] + ",toOn:=" + operArray[t][2] + ",noise_time:=" + operArray[t][3] + "]]";
                groCode2 = groCode2 + 'genes([name:="' + operArray[t][0] + '",' + writeProtein(operArray[t][0], noise);
            }
        }
        return groCode2;
    }

    /**---------------------------------------------------------------------------------------------
     FUNCIONES RELATIVA A LA CODIFICACION DE LAS PROTEINAS
     -----------------------------------------------------------------------------------------------**/
    function writeProtein(operonName, noise) {
        var xx = buscaNombre(operonName, protArray);
        var groCode1;
        for (var t = 0; t < xx.length; t++) {
            if (t == 0) {
                groCode1 = 'proteins:={"' + xx[0][1] + '"';
            }
            else {
                groCode1 = groCode1 + ',"' + xx[t][1] + '"';
            }
        }
        groCode1 = groCode1 + "}," + writePromoter(operonName) + ",";
        for (var t = 0; t < xx.length; t++) {
            var groAct;
            var groDeact;
            var groletA;
            var groletD;
            var groNoiseOn;
            var groNoiseOff;
            var groTnoise;
            if (t == 0) {
                groAct = "prot_act_times:=[times:={" + xx[0][2];
                groDeact = "prot_deg_times:=[times:={" + xx[0][3];
                groletA = ",letiabilities:={" + xx[0][4];
                groletD = ",letiabilities:={" + xx[0][5];
            }
            else {
                groAct = groAct + "," + xx[t][2];
                groDeact = groDeact + "," + xx[t][3];
                groletA = groletA + "," + xx[t][4];
                groletD = groletD + "," + xx[t][5];
            }
        }
        groCode1 = groCode1 + noise + "," + groAct + "}" + groletA + "}]," + groDeact + "}" + groletD + "}]]);\n";
        return groCode1;
    }

    /**---------------------------------------------------------------------------------------------
     FUNCION CODIFICADORA RELATIVA A LOS PLASMIDOS
     -----------------------------------------------------------------------------------------------**/
    function writePlasmid() {
        groCode = writeExperiment() + signalCode + writeGenes();
        var groPlas;
        for (var t = 0; t < plasArray.length; t++) {
            if (t == 0) {
                groPlas = "plasmids_genes([" + plasArray[0][1] + ":={";
                for (var h = 2; h < plasArray[t].length; h++) {
                    if (h == 2) {
                        groPlas = groPlas + '"' + plasArray[0][h] + '"';
                    }
                    else {
                        groPlas = groPlas + ',"' + plasArray[0][h] + '"';
                    }
                }
                groPlas = groPlas + "}";
            }
            else {
                groPlas = groPlas + "," + plasArray[t][1] + ":={";
                for (var h = 2; h < plasArray[t].length; h++) {
                    if (h == 2) {
                        groPlas = groPlas + '"' + plasArray[t][h] + '"';
                    }
                    else {
                        groPlas = groPlas + ',"' + plasArray[t][h] + '"';
                    }
                }
                groPlas = groPlas + "}";
            }
        }
        return groCode = groCode + groPlas + "]);\n";
    }

    /**---------------------------------------------------------------------------------------------
     FUNCION CODIFICADORA RELATIVA A LAS BACTERIAS
     -----------------------------------------------------------------------------------------------**/
    function writeCell() {
        var code2 = "";
        for (var t = 0; t < cellArray.length; t++) {
            var xx = buscaNombre(cellArray[t][0], plasArray);
            code2 = code2 + "c_ecolis(" + cellArray[t][1] + "," + cellArray[t][2] + "," + cellArray[t][3] + "," + cellArray[t][4] + ",{";
            for (var h = 0; h < xx.length; h++) {
                code2 = code2 + '"' + xx[h][1] + '"';
                if (h + 1 != xx.length) {
                    code2 = code2 + ",";
                }
            }
            code2 = code2 + "},program p());"

        }

        return code2;
    }

    function writeMain() {
        return code = writePlasmid() + actionCode + programCode + "program main():={" + writeCell() + "};\n";
    }

    /**---------------------------------------------------------------------------------------------
     FUNCIONES AUXILIARES
     -----------------------------------------------------------------------------------------------**/
    function buscaNombre(nombre, arr) {
        var data_arrays = [];
        for (var t = 0; t < arr.length; t++) {
            if (arr[t][0] == nombre) {
                data_arrays.push(arr[t]);
            }
        }
        return data_arrays;
    }

    /**---------------------------------------------------------------------------------------------
     FUNCION QUE INICIA LA CODIFICIACION DE BLOQUES
     -----------------------------------------------------------------------------------------------**/
    function myGenerator() {
        /**---------------------------------------------------------------------------------------------
         VECTORES DE CARGA DE LA INFORMACION
         -----------------------------------------------------------------------------------------------**/
        promArray = [];
        protArray = [];
        operArray = [];
        plasArray = [];
        expArray = [];
        cellArray = [];
        transFactors = [];
        groCode = 'include gro ';
        actionCode = "";
        signalCode = "";
        programCode = "program p():={skip();};";
        var xx = [];
        totalBlocks = this.workspace.getAllBlocks();

        console.log("Calling myGenerator");
        console.log(totalBlocks);

        for (var t = 0; t < totalBlocks.length; t++) {
            /**---------------------------------------------------------------------------------------------
             CARGA DE INFORMACION DE LOS BLOQUES GENETICOS PARA CODIFICAR LOS DATOS
             -----------------------------------------------------------------------------------------------**/
            if (totalBlocks[t].getInput("Experiment")) {
                expArray.push([totalBlocks[t].getFieldValue('dt'), totalBlocks[t].getFieldValue('Mppl')]);
            }
            if (totalBlocks[t].getInput("Ecoli")) {
                cellArray.push([totalBlocks[t].getFieldValue('NAME'), totalBlocks[t].getFieldValue('Ncells'), totalBlocks[t].getFieldValue('x'), totalBlocks[t].getFieldValue('y'), totalBlocks[t].getFieldValue('Radius'), totalBlocks[t].getFieldValue('Volume')]);
            }
            if (totalBlocks[t].getInput("Plasmid")) {
                xx = [totalBlocks[t].getSurroundParent().getFieldValue("NAME"), totalBlocks[t].getFieldValue('NAME')];
                var des = totalBlocks[t].getDescendants();
                for (var h = 1; h < des.length; h++) {
                    if (des[h].getInput("Operon") && des[h].getSurroundParent() == totalBlocks[t]) {
                        xx.push(des[h].getFieldValue("NAME"));
                    }
                }
                plasArray.push(xx);
            }
            if (totalBlocks[t].getInput("Operon")) {
                operArray.push([totalBlocks[t].getFieldValue('NAME'), totalBlocks[t].getFieldValue('Nup'), totalBlocks[t].getFieldValue('Ndown'), totalBlocks[t].getFieldValue('Tnoise')]);
            }
            if (totalBlocks[t].getInput("Promoter")) {
                var tt = [totalBlocks[t].getParent().getFieldValue('NAME'), totalBlocks[t].getFieldValue('GATE')];
                for (var h = 1; h < totalBlocks[t].getDescendants().length; h++) {
                    tt.push(totalBlocks[t].getDescendants()[h].getFieldValue("NAME"));
                }
                promArray.push(tt);
            }
            if (totalBlocks[t].getInput("Protein")) {
                if (totalBlocks[t].getParent().getInput("Operon")) {
                    protArray.push([totalBlocks[t].getParent().getFieldValue('NAME'), totalBlocks[t].getFieldValue('NAME'), totalBlocks[t].getFieldValue('Act'), totalBlocks[t].getFieldValue('Deac'), totalBlocks[t].getFieldValue('Vup'), totalBlocks[t].getFieldValue('Vdown')]);
                }
                if (totalBlocks[t].getParent().getInput("Protein")) {
                    var found = false;
                    var parent = totalBlocks[t].getParent();
                    while (!found) {
                        parent = parent.getParent();
                        if (parent.getInput("Operon")) {
                            found = true;
                            protArray.push([parent.getFieldValue('NAME'), totalBlocks[t].getFieldValue('NAME'), totalBlocks[t].getFieldValue('Act'), totalBlocks[t].getFieldValue('Deac'), totalBlocks[t].getFieldValue('Vup'), totalBlocks[t].getFieldValue('Vdown')]);
                        }
                    }
                }
            }
            /**---------------------------------------------------------------------------------------------
             ESCRITURA DE LOS BLOQUES DE ACCIONES
             -----------------------------------------------------------------------------------------------**/

            if (totalBlocks[t].getInput("Action")) {
                var des = totalBlocks[t].getDescendants();
                var conditions = "";


                /**
                 * Todas las acciones se componen de un vector de condiciones , un tipo de accion y
                 * parametros relativos a esa informacion por lo tanto la codificacion del vector de
                 * condiciones sera igual en todos los casos.
                 *
                 * Una vez codificado este vector se escribe el resto de la informacion dependiendo del tipo
                 * de accion que se haya unido al bloque accion.
                 * */
                for (var h = 1; h < des.length; h++) {
                    if (des[h].getParent() == totalBlocks[t]) {
                        if (des[h].getInput("ProteinL")) {
                            conditions = '"' + des[h].getFieldValue("NAME") + '"';
                            for (var y = 1; y < des[h].getDescendants().length; y++) {
                                conditions = conditions + ',"' + des[h].getDescendants()[y].getFieldValue("NAME") + '"';
                            }

                        }
                        if (des[h].getInput("Paint")) {
                            codeA = '},"' + des[h].getFieldValue("TYPE") + '",{"' + des[h].getFieldValue("Fst") + '","' + des[h].getFieldValue("Snd") + '","' + des[h].getFieldValue("Thr") + '","' + des[h].getFieldValue("Fhr") + '"});'
                        }
                        if (des[h].getInput("Paint2")) {
                            codeA = '},"' + des[h].getFieldValue("TYPE") + '",{' + des[h].getFieldValue("COLOUR") + '});'
                        }
                        if (des[h].getInput("Conjugate")) {
                            codeA = '},"' + des[h].getFieldValue("TYPE") + '",{"' + des[h].getFieldValue("NAME") + '","' + des[h].getFieldValue("ratio") + '"});'
                        }
                        if (des[h].getInput("ActionR1")) {
                            codeA = '},"' + des[h].getFieldValue("TYPE") + '",{"' + des[h].getFieldValue("NAME") + '"});'
                        }
                        if (des[h].getInput("ActionR2")) {
                            codeA = '},"' + des[h].getFieldValue("TYPE") + '",{tostring(' + des[h].getFieldValue("ID") + '),"' + des[h].getFieldValue("Snd") + '","' + des[h].getFieldValue("eTYPE") + '"});'
                        }
                        if (des[h].getInput("ActionR3")) {
                            codeA = '},"' + des[h].getFieldValue("TYPE") + '",{tostring(' + des[h].getFieldValue("ID") + '),"' + des[h].getFieldValue("COMPARISON") + '","' + des[h].getFieldValue("Snd") + '","' + des[h].getFieldValue("PROTEIN") + '"});'
                        }

                    }


                }

                actionCode = actionCode + 'action({' + conditions + codeA;
                actionCode = actionCode + "\n";
            }

            /**---------------------------------------------------------------------------------------------
             ESCRITURA DE LOS MODULOS Y LAS SEÃALES
             -----------------------------------------------------------------------------------------------**/
            if (totalBlocks[t].getInput("Nutrients")) {
                signalCode = signalCode + 'set("nutrients", 1.0);\nset("nutrients_amount",' + totalBlocks[t].getFieldValue("NAM") + ');\nset("nutrient_consumption_rate",' + totalBlocks[t].getFieldValue("NCR") + ');\nset("nutrient_grid_length",' + totalBlocks[t].getFieldValue("NGL") + ');\nset("nutrient_grid_cell_size",' + totalBlocks[t].getFieldValue("NGCS") + ');\nset("nutrient_consumption_mode",' + totalBlocks[t].getFieldValue('NCM') + ');\n';
            }
            if (totalBlocks[t].getInput("Signal")) {
                signalCode = signalCode + totalBlocks[t].getFieldValue("NAME") + ':= s_signal([kdiff:=' + totalBlocks[t].getFieldValue("KDIFF") + ",kdeg:=" + totalBlocks[t].getFieldValue("KDEG") + "]);\n"
            }
            if (totalBlocks[t].getInput("Signal_Settings")) {
                signalCode = signalCode + 'set("signals", 1.0);set("signals_draw",' + totalBlocks[t].getFieldValue("POWER") + ');set_param("signals_grid_length",' + totalBlocks[t].getFieldValue("LENGTH") + ');set_param("signals_grid_cell_size",' + totalBlocks[t].getFieldValue("SIZE") + ');set_param("signals_grid_neighborhood",' + totalBlocks[t].getFieldValue("NBH") + ');\n';
            }
            if (totalBlocks[t].getInput("DumpSingle")) {
                programCode = 'program p() :={ selected:{ dump_single( fopen(' + totalBlocks[t].getFieldValue("ROUTE") + ' <> ' + totalBlocks[t].getFieldValue("FN") + ' <> tostring((' + totalBlocks[t].getFieldValue("RT") + '+1)) <> ".csv", "w"));}};\n';
            }


        }
        //SALIDA POR PANTALLA
//    var finalCode = writeMain();
        //   document.getElementById("groDiv").innerHTML =finalCode;
    }

    /******************************************************************************
     ENVIO CODIGO GENERADO AL SIMULADOR GROW
     **********************************************************************************/
    function simulate() {
        try {
            var code = writeMain();

            var f = new File([code], 'experiment.gro');
            var formData = new FormData();
            var request = new XMLHttpRequest();
            var url = '/growckly';

            formData.append("userfile", f);

            //  formData = new FormData(document.querySelector("form"));

            request.open("POST", url, false);

            request.onreadystatechange = function () {
                if (this.readyState === 4 && this.status === 200) {
                    document.open();
                    document.write(request.response);
                    document.close();
                }
            };

            request.send(formData);
        } catch (ex) {
            alert("You have to create the experiment by clicking in 'Generate' button before simulating");
        }
    }

</script>

<button type="button" onclick="addBlock()">Generate Block</button>
<button type="button" onclick="myGenerator()">Generate!</button>
<button id="save-btn">Save</button>
<button id="simulate" onclick="simulate()">Simulate</button>
<form enctype="multipart/form-data">
    <input id="upload" type="file" accept=".gro" name="file" size=1>
</form>

<script>

    /*
        TRADUCTOR DE GRO A GROCKLY
    */

    //variables globales del programa
    let comment;
    let operons;
    let plasmids;
    let actions;
    let experiment;
    let nutrients;
    let signals;
    let dumpSingle;

    /*
        Funcion de manejo de archivos
    */

    document.getElementById('upload').addEventListener('change', handleFile, false);

    function handleFile(event) {

        if (!confirm("If you load a gro file, it will be automatically converted and your current code" +
                " will be deleted. Please save your workspace first. Are you sure you want to continue?")) return alert;

        document.getElementById('upload').removeEventListener('change', handleFile, false);
        document.getElementById('upload').addEventListener('change', handleFile, false);

        let files = event.target.files; // FileList object
        let file = files[0];

        //comprobacion de si el archivo es .gro
        if (file.name.split(".")[1] === "gro") {
            let reader = new FileReader();
            reader.onload = function () {
                workspace.clear();
                comment = false;
                operons = [];
                plasmids = [];
                actions = [];
                experiment = undefined;
                nutrients = undefined;
                signals = undefined;
                dumpSingle = undefined;


                let lines = this.result.split('\n');
                for (let lineNo = 0; lineNo < lines.length; lineNo++) {
                    let line = lines[lineNo];

                    console.log(line);
                    //funcion auxiliar para parsear cada linea de codigo
                    parse(line);
                }
            };
            reader.readAsText(file);
        } else {
            alert("Please select a .gro file");
        }
    }

    /*
        Funcion para determinar que tipo de expresion contiene cada linea de codigo
    */
    function parse(line) {
        //ignora comentarios
        if (line.startsWith("/*")){
            comment = true;
        } else if (line.includes("*/")){
            comment = false;
        } else if (comment){
            //el texto dentro del comentario se ignora
        } else if (line.startsWith("action")){
            parseAction(line);
        } else if (line.startsWith("set")) {
            parseSet(line);
        } else if (line.includes("s_signal")){
            parseSignal(line);
        } else if (line.startsWith("genes")){
            parseOperon(line);
        } else if (line.startsWith("plasmids_genes")){
            parsePlasmid(line);
        } else if (line.startsWith("program")) {
            if (line.includes("c_ecolis")) {
                parseEcolis(line);
            }else if (line.includes("dump_single")){
                parseDumpSingle(line);
            }
        }
    }

    /*
        Funcion para extraer los datos necesarios para las instrucciones de tipo 'action'
    */
    function parseAction(line) {
        let sets = line.split("action(");
        for (let i = 1; i < sets.length; i++){
            let data = sets[i];
            let aux = data.replace(/"/g, "").replace(/{/g, "").replace(/}/g, "");
            aux = aux.split(");")[0];
            aux = aux.split(",");
            createBlock("Action", aux);
        }
    }

    /*
        Funcion para extraer los datos necesarios para las instrucciones de tipo 'set'
    */
    function parseSet(line) {
        let sets = line.split("set");
        for (let i = 1; i < sets.length; i++){
            let data = sets[i];
            if (data.includes("nutrient")){
                changeBlock("nutrients", data);
            } else if(data.includes("signals")){
                changeBlock("signal_settings", data);
            } else {
                changeBlock("set", data);
            }
        }
    }

    /*
        Funcion para extraer los datos necesarios para las instrucciones de tipo 's_signal'
    */
    function parseSignal(line) {
        let data = line.split(":=");
        let params = [];
        params[0] = data[0].replace(/ /g, "");
        data = line.split(",");
        params[1] = data[0].split("kdiff:=")[1];
        params[2] = data[1].split(":=")[1].split("]")[0];
        createBlock("Signal", params);
    }

    /*
        Funcion para extraer los datos necesarios para las instrucciones de tipo 'genes' (operon)
        Esto incluye tambien los bloques 'protein', 'promoter' y 'proteinL' (lista de proteinas para 'promoter')
    */
    function parseOperon(line){
        let operonData = [];
        let proteinData = [];
        let promoterData = [];
        if(line.includes("name")){
            let name = line.split("name:=")[1];
            name = name.split(',')[0];
            name = name.replace(/"/g, "");
            operonData[0] = name;
        }
        if(line.includes("proteins")){
            let data = line.split("proteins:={")[1];
            data = data.split("}")[0];
            data = data.replace(/"/g, "");
            data = data.split(",");

            let aux = line.split("prot_act_times:=[")[1];
            aux = aux.split("]")[0];

            let tAct = aux.split("{")[1];
            tAct = tAct.split("}")[0];
            tAct = tAct.split(",");

            let tDeact = aux.split("},")[1];
            tDeact = tDeact.split("{")[1];
            tDeact = tDeact.split(",");

            let aux2 = line.split("prot_deg_times:=[")[1];
            aux2 = aux2.split("]")[0];

            let varUp = aux2.split("{")[1];
            varUp = varUp.split("}")[0];
            varUp = varUp.split(",");

            let varDown = aux2.split("},")[1];
            varDown = varDown.split("{")[1];
            varDown = varDown.split(",");

            for (let i = 0; i < data.length; i++){
                //nombre, tact, varup, tdeact, vardown
                proteinData[i]=[data[i], tAct[i], varUp[i], tDeact[i], varDown[i]];
            }
        }
        if(line.includes("promoter")){
            let data = line.split("promoter:=[")[1];
            data = data.split("]")[0];

            //function
            let fun = data.split("function:=")[1];
            fun = fun.split(",")[0];
            fun = fun.replace(/"/g, "");
            promoterData[0] = fun;

            //add ProteinL block with ProteinL field
            let factor = data.split("transcription_factors:={")[1];
            factor = factor.split("}")[0];
            factor = factor.replace(/"/g, "");
            factor = factor.split(",");
            if(factor[0] === ""){
                promoterData[1] = 0;
            }else {
                promoterData[1] = factor;
            }

            //noise
            if(line.includes("noise")){
                let noise = data.split("noise:=[")[1];
                noise = noise.split("]")[0];
                noise = noise.split(",");
                noise[0] = noise[0].split("toOff:=")[1];
                noise[1] = noise[1].split("toOn:=")[1];
                noise[2] = noise[2].split("noise_time:=")[1];
                operonData[1] = noise[0];
                operonData[2] = noise[1];
                operonData[3] = noise[2];
            }
        }
        createOperonBlock(operonData, promoterData, proteinData);
    }

    /*
        Funcion para extraer los datos necesarios para las instrucciones de tipo 'plasmids_genes'
    */
    function parsePlasmid(line){
        let data = line.split("[")[1];
        data = data.split("]")[0];
        /*for(let i = 0; i < 3; i++) {
            let temp = ["P1", "P3", "P2"];
            let temp2 = ["O1", ["O2", "O3"], "O3"];
            plasmids.push({plName: temp[i], opNames: temp2[i]});
        }*/
        let aux2 = data.split("},");
        for(let i = 0; i < aux2.length; i++){
            let name = aux2[i].split(":={")[0];
            let operons = aux2[i].split(":={")[1].replace(/"/g, '').replace(/}/g, '');
            if(operons.includes(",")){
                operons = operons.split(",");
            }
            plasmids.push({ plName : name, opNames : operons });
        }
    }

    /*
        Funcion para extraer los datos necesarios para las instrucciones de tipo 'c_ecolis'
    */
    function parseEcolis(line) {
        let data = line.split("c_ecolis");
        let params = [];
        for(let i = 1; i < data.length; i++){
            let aux = data[i];
            aux = aux.split(",");
            aux.pop();
            for(let j = 4; j < aux.length; j++) {
                if(aux[j].includes("{")){
                    aux[j] = aux[j].split("{")[1];
                }
                if(aux[j].includes("}")){
                    aux[j] = aux[j].split("}")[0];
                }
                aux[j] = aux[j].replace(/"/g, "");
            }
            params[i] = aux;
            createBlock("Ecoli", params[i]);
        }
    }

    /*
        Funcion para extraer los datos necesarios para las instrucciones de tipo 'dump_single'
    */
    function parseDumpSingle(line) {
        let data = line.split("dump_single")[1];
        data = data.split(" <> ");
        let params = [];
        params[0] = data[0].split("fopen(")[1].replace(/ /g, "");
        params[1] = data[1];
        if(data[2].includes("tostring(")){
            params[2] = data[2].split("tostring")[1].split("+")[0].replace("(", "");
            params[2] = params[2].replace("(", "");
        } else if(data[2].includes("toString(")){
            params[2] = data[2].split("toString")[1].split("+")[0].replace("(", "");
            params[2] = params[2].replace("(", "");
        }else{
            params[2] = data[2];
        }
        createBlock("DumpSingle", params);
    }

    /*
        Funcion crear o modificar el bloque 'Experiment', que contiene los datos de paso de tiempo (dt)
        y poblacion maxima (population_max)
    */
    function changeBlock(type, data) {
        console.log("change Block: " + type);
        if (type === "set") {
            if (experiment === undefined) {
                experiment = workspace.newBlock("Experiment");
            }

            if (data.startsWith('("dt"')) {
                experiment.setFieldValue(data.split(",")[1], "dt");
            } else if (data.startsWith('("population_max"')) {
                experiment.setFieldValue(data.split(",")[1], "Mppl");
            }
            renderBlock(experiment);
        } else if (type === "nutrients") {
            if (nutrients === undefined) {
                nutrients = workspace.newBlock("Nutrients");
            }
            if (!nutrients.previousConnection.isConnected()){
                let parentConnection = experiment.nextConnection;
                let childConnection = nutrients.previousConnection;
                parentConnection.connect(childConnection);
            }
            if (data.startsWith('("nutrients_amount"')) {
                nutrients.setFieldValue(data.split(",")[1], "NAM");
            } else if (data.startsWith('("nutrient_consumption_rate"')) {
                nutrients.setFieldValue(data.split(",")[1], "NCR");
            } else if (data.startsWith('("nutrient_grid_length"')) {
                nutrients.setFieldValue(data.split(",")[1], "NGL");
            } else if (data.startsWith('("nutrient_grid_cell_size"')) {
                nutrients.setFieldValue(data.split(",")[1], "NGCS");
            } else if (data.startsWith('("nutrient_consumption_mode"')) {
                nutrients.setFieldValue(data.split(",")[1].split(");")[0], "NCM");
            }
            renderBlock(nutrients);
        } else if (type === "signal_settings"){
            if(signals === undefined){
                signals = workspace.newBlock("Signal_Settings");
            }
            if (!signals.previousConnection.isConnected() && nutrients === undefined){
                let parentConnection = experiment.nextConnection;
                let childConnection = signals.previousConnection;
                parentConnection.connect(childConnection);
            } else if(nutrients !== undefined){
                let parentConnection = nutrients.nextConnection;
                let childConnection = signals.previousConnection;
                parentConnection.connect(childConnection);
            }

            if (data.startsWith('("signals_draw"')) {
                signals.setFieldValue(data.split(",")[1].replace(");", ""), "POWER");
            } else if (data.startsWith('_param("signals_grid_length"')) {
                signals.setFieldValue(data.split(",")[1], "LENGTH");
            } else if (data.startsWith('_param("signals_grid_cell_size"')) {
                signals.setFieldValue(data.split(",")[1], "SIZE");
            } else if (data.startsWith('_param("signals_grid_neighborhood"')) {
                signals.setFieldValue(data.split(",")[1], "NBH");
            }
            renderBlock(signals);
        }
    }

    /*
        Funcion que toma un tipo de bloque y los datos necesarios para su creacion y conexion
        y crea dicho bloque, rellenando sus campos y conectandolo con los bloques pertinentes
     */
    function createBlock(type, data) {
        console.log("Create Block: " + type);
        //tambien creamos el plasmido aqui porque el nombre del plasmido aparece en el bloque c_ecolis
        if (type === "Ecoli") {
            let block = workspace.newBlock(type);
            block.setFieldValue(data[0].split("(")[1], "Ncells");
            block.setFieldValue(data[1], "x");
            block.setFieldValue(data[2], "y");
            block.setFieldValue(data[3], "Radius");

            //conexion de experiment con ecoli
            let parentConnection = experiment.getInput('Experiment').connection;
            let childConnection = block.previousConnection;
            parentConnection.connect(childConnection);

            //creacion de plasmid
            if(data.length === 5){
                let plasmidLocal = workspace.newBlock("Plasmid");
                plasmidLocal.setFieldValue(data[4], "NAME");

                //conexion de ecoli con plasmid
                renderBlock(plasmidLocal);

                let plasmidName;
                let operonsInPlasmid;
                for(let i = 0; i < plasmids.length; i++){
                    if (plasmids[i].plName === plasmidLocal.getInput("Plasmid").fieldRow[1].getText()){
                        plasmidName = plasmids[i].plName;
                        operonsInPlasmid = plasmids[i].opNames;
                    }
                }

                //conexion de plasmid con operon
                if(plasmidName !== undefined && operonsInPlasmid !== undefined) {
                    let parentConnection3 = plasmidLocal.getInput('Plasmid').connection;
                    for (let i = 0; i < operons.length; i++) {
                        if (operonsInPlasmid.constructor === Array) {
                            for (let j = 0; j < operonsInPlasmid.length; j++) {
                                if (operons[i].name === operonsInPlasmid[j]) {
                                    operonsInPlasmid.splice(j, 1);
                                    let childConnection3 = workspace.getBlockById(operons[i].id).previousConnection;
                                    parentConnection3.connect(childConnection3);
                                }
                            }
                        } else {
                            if (operons[i].name === operonsInPlasmid) {
                                operonsInPlasmid = "";
                                let childConnection3 = workspace.getBlockById(operons[i].id).previousConnection;
                                parentConnection3.connect(childConnection3);
                            }
                        }
                    }
                }

                let parentConnection2 = block.getInput('Ecoli').connection;
                let childConnection2 = plasmidLocal.previousConnection;
                parentConnection2.connect(childConnection2);

            }else if(data.length > 5){
                let plasmidsLocal = [];
                for (let y = 0; y < data.length-4; y++) {
                    plasmidsLocal[y] = workspace.newBlock("Plasmid");
                    plasmidsLocal[y].setFieldValue(data[y+4], "NAME");
                    renderBlock(plasmidsLocal[y]);

                    let plasmidNames;
                    let operonsInPlasmid;
                    for(let j = 0; j < plasmids.length; j++){
                        if (plasmids[j].plName === plasmidsLocal[y].getInput("Plasmid").fieldRow[1].getText()){
                            plasmidNames = plasmids[j].plName;
                            operonsInPlasmid = plasmids[j].opNames;
                        }
                    }
                    //conexion de plasmid con operon
                    let parentConnection3 = plasmidsLocal[y].getInput('Plasmid').connection;
                    for (let i = 0; i < operons.length; i++) {
                        if (operonsInPlasmid.constructor === Array) {
                            for (let j = 0; j < operonsInPlasmid.length; j++) {
                                if (operons[i].name === operonsInPlasmid[j]) {
                                    if(!workspace.getBlockById(operons[i].id).previousConnection.isConnected()) {
                                        operonsInPlasmid.splice(j, 1);
                                        let childConnection3 = workspace.getBlockById(operons[i].id).previousConnection;
                                        parentConnection3.connect(childConnection3);
                                    }
                                }
                            }
                        } else {
                            if (operons[i].name === operonsInPlasmid) {
                                if(!workspace.getBlockById(operons[i].id).previousConnection.isConnected()) {
                                    operonsInPlasmid = "";
                                    let childConnection3 = workspace.getBlockById(operons[i].id).previousConnection;
                                    parentConnection3.connect(childConnection3);
                                }
                            }
                        }
                    }

                    //conexion de ecoli con plasmid
                    if (y !== 0) {
                        let parentConnection2 = plasmidsLocal[y-1].nextConnection;
                        let childConnection2 = plasmidsLocal[y].previousConnection;
                        parentConnection2.connect(childConnection2);
                    }
                    if(y === data.length-5){
                        let parentConnection2 = block.getInput('Ecoli').connection;
                        let childConnection2 = plasmidsLocal[0].previousConnection;
                        parentConnection2.connect(childConnection2);

                    }

                }
            }

            renderBlock(block);

        } else if (type === "Action"){

            let block = workspace.newBlock(type);
            actions.push(block);
            let protBlock = workspace.newBlock("ProteinL");
            let actionBlock;
            protBlock.setFieldValue(data[0], "NAME");
            protBlock.getField("NAME");
            if (data[1] === "paint" || data[1] === "d_paint") {
                if(data.length === 3){
                    actionBlock = workspace.newBlock("Paint2");
                    actionBlock.setFieldValue(data[2], "COLOUR");
                } else {
                    actionBlock = workspace.newBlock("Paint");
                    actionBlock.setFieldValue(data[2], "Fst");
                    actionBlock.setFieldValue(data[3], "Snd");
                    actionBlock.setFieldValue(data[4], "Thr");
                    actionBlock.setFieldValue(data[5], "Fhr");
                }
            } else if (data[1] === "conjugate" || data[1] === "conjugate_directed") {
                actionBlock = workspace.newBlock("Conjugate");
                actionBlock.setFieldValue(data[2], "NAME");
                actionBlock.setFieldValue(data[3], "ratio");
            } else if (data[1] === "lose_plasmid" || data[1] === "set_eex" || data[1] === "remove_eex") {
                actionBlock = workspace.newBlock("ActionR1");
                actionBlock.setFieldValue(data[2], "NAME");
            } else if (data[1] === "s_emit_signal" || data[1] === "s_emit_cf") {
                actionBlock = workspace.newBlock("ActionR2");
                if(data[2].includes("tostring")){
                    data[2] = data[2].replace("tostring(", "").replace(")", "");
                }
                actionBlock.setFieldValue(data[2], "ID");
                actionBlock.setFieldValue(data[3], "Snd");
                actionBlock.setFieldValue(data[4], "eTYPE");
            } else if (data[1] === "s_absorb_QS" || data[1] === "s_get_QS") {
                actionBlock = workspace.newBlock("ActionR3");
                if(data[2].includes("tostring")){
                    data[2] = data[2].replace("tostring(", "").replace(")", "");
                }
                actionBlock.setFieldValue(data[2], "ID");
                actionBlock.setFieldValue(data[3], "COMPARISON");
                actionBlock.setFieldValue(data[4], "Snd");
                actionBlock.setFieldValue(data[5], "PROTEIN");
            }

            if(actionBlock !== undefined) {
                let parentConnection3; let childConnection3;
                //Conexion de bloque con bloque de experimento
                if(actions.length > 1){
                    parentConnection3 = actions[actions.length-2].nextConnection;
                    childConnection3 = block.previousConnection;
                    parentConnection3.connect(childConnection3);
                } else if(signals !== undefined) {
                    let found = false; let first = true;
                    let children = []; let parent = [];
                    let child;
                    while(!found){
                        if(first){
                            children = signals.childBlocks_;
                            first = false;
                        }else {
                            children = parent.childBlocks_;
                        }
                        if(children.length === 0) {
                            if(parent.length === 0){
                                child = signals;
                            }else {
                                child = parent;
                            }
                            found = true;
                        } else{
                            parent = children[0];
                        }
                    }
                    parentConnection3 = child.nextConnection;
                    childConnection3 = block.previousConnection;
                    parentConnection3.connect(childConnection3);
                } else if(nutrients !== undefined) {
                    parentConnection3 = nutrients.nextConnection;
                    childConnection3 = block.previousConnection;
                    parentConnection3.connect(childConnection3);
                } else if(dumpSingle !== undefined) {
                    parentConnection3 = dumpSingle.nextConnection;
                    childConnection3 = block.previousConnection;
                    parentConnection3.connect(childConnection3);
                } else {
                    parentConnection3 = experiment.nextConnection;
                    childConnection3 = block.previousConnection;
                    parentConnection3.connect(childConnection3);
                }

                //Conexion de bloque Action con bloque ProteinL
                renderBlock(protBlock);
                let parentConnection = block.getInput('ProteinL').connection;
                let childConnection = protBlock.outputConnection;
                parentConnection.connect(childConnection);

                //Conexion de bloque Action con bloque de accion interior
                renderBlock(actionBlock);
                let parentConnection2 = block.getInput('Action').connection;
                let childConnection2 = actionBlock.outputConnection;
                parentConnection2.connect(childConnection2);

            }
            renderBlock(block);
        } else if(type === "Signal"){
            let block = workspace.newBlock(type);
            block.setFieldValue(data[0], "NAME");
            block.setFieldValue(data[1], "KDIFF");
            block.setFieldValue(data[2], "KDEG");

            renderBlock(block);
            let parentConnection = signals.nextConnection;
            let childConnection = block.previousConnection;
            parentConnection.connect(childConnection);

        } else if(type === "DumpSingle"){
            dumpSingle = workspace.newBlock(type);
            dumpSingle.setFieldValue(data[0], "ROUTE");
            dumpSingle.setFieldValue(data[1], "FN");
            dumpSingle.setFieldValue(data[2], "RT");

            renderBlock(dumpSingle);
            let parentConnection = experiment.nextConnection;
            let childConnection = dumpSingle.previousConnection;
            parentConnection.connect(childConnection);

            if(nutrients !== undefined) {
                let parentConnection2 = dumpSingle.nextConnection;
                let childConnection2 = nutrients.previousConnection;
                parentConnection2.connect(childConnection2);
            } else if(signals !== undefined) {
                let parentConnection2 = dumpSingle.nextConnection;
                let childConnection2 = signals.previousConnection;
                parentConnection2.connect(childConnection2);
            }
        }
    }


    /*
        Funcion que toma los datos necesarios para la creacion y conexion de operones y sus componentes
    */
    function createOperonBlock(operonData, promoterData, proteinData){

        console.log("Create Block: Operon");
        let operonBlock = workspace.newBlock("Operon");
        operonBlock.setFieldValue(operonData[0], "NAME");
        operonBlock.setFieldValue(operonData[1], "Nup");
        operonBlock.setFieldValue(operonData[2], "Ndown");
        operonBlock.setFieldValue(operonData[3], "Tnoise");

        operons.push({id: operonBlock.id, name: operonData[0]});

        renderBlock(operonBlock);

        let promoterBlock = workspace.newBlock("Promoter");
        promoterBlock.setFieldValue(promoterData[0], "GATE");
        if (promoterData[1] !== 0) { //si hay un 0 quiere decir que el promotor no toma ninguna proteina
            let proteinList = [];
            for (let i = 0; i < promoterData[1].length; i++) {
                proteinList[i] = workspace.newBlock("ProteinL");
                proteinList[i].setFieldValue(promoterData[1][i], "NAME");

                renderBlock(proteinList[i]);
                let parentConnection = promoterBlock.getInput('ProteinL').connection;
                let childConnection = proteinList[i].outputConnection;
                parentConnection.connect(childConnection);
            }
        }

        //connection to operon

        let parentConnection = operonBlock.getInput('Operon').connection;
        let childConnection = promoterBlock.outputConnection;
        parentConnection.connect(childConnection);

        renderBlock(promoterBlock);

        let proteinBlocks = [];
        for (let i = 0; i < proteinData.length; i++) {
            proteinBlocks[i] = workspace.newBlock("Protein");
            proteinBlocks[i].setFieldValue(proteinData[i][0], "NAME");
            proteinBlocks[i].setFieldValue(proteinData[i][1], "Act");
            proteinBlocks[i].setFieldValue(proteinData[i][2], "Deac");
            proteinBlocks[i].setFieldValue(proteinData[i][3], "Vup");
            proteinBlocks[i].setFieldValue(proteinData[i][4], "Vdown");

            //connection to operon
            if(i === 0){
                let parentConnection2 = operonBlock.getInput('NAME').connection;
                let childConnection2 = proteinBlocks[i].outputConnection;
                parentConnection2.connect(childConnection2);
            } else {
                let parentConnection2 = proteinBlocks[i-1].getInput("Protein").connection;
                let childConnection2 = proteinBlocks[i].outputConnection;
                parentConnection2.connect(childConnection2);
            }
        }

        renderBlocks(proteinBlocks);
    }

    /*
        Funciones para renderizar un bloque o un array de bloques
    */
    function renderBlock(block){
        block.initSvg();
        block.render();
    }

    function renderBlocks(blocks){
        for(let i = 0; i < blocks.length; i++) {
            blocks[i].initSvg();
            blocks[i].render();
        }
    }

    /*
        Funcion de prueba para debug
    */
    function addBlock() {
        let parentBlock = workspace.newBlock("Experiment");
        parentBlock.initSvg();
        parentBlock.render();

        let childBlock = workspace.newBlock("Ecoli");
        childBlock.initSvg();
        childBlock.render();

        let parentConnection = parentBlock.getInput('Experiment').connection;
        let childConnection = childBlock.previousConnection;
        parentConnection.connect(childConnection);
    }

    $("#save-btn").click(function () {
        var finalCode = writeMain();
        var blob = new Blob([finalCode], {type: "text/plain;charset=utf-8"});
        saveAs(blob, "test.gro");
    });

</script>

</body>
</html>
